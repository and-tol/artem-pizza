{"ast":null,"code":"import { createAction, createAsyncThunk } from '@reduxjs/toolkit'; // Api\n\nimport { api } from '../../../api'; // ActionTypes\n\nimport { checkoutActionTypes } from './checkoutActionTypes';\nexport const startFetching = createAction('CHECKOUT_START_FETCHING');\nexport const stopFetching = createAction('CHECKOUT_STOP_FETCHING');\nexport const setFetchingError = createAction('CHECKOUT_SET_FETCHING_ERROR');\nexport const fillOrder = createAction('CHECKOUT_FILL');\nexport const setAccept = createAction('CHECKOUT_SET_ACCEPT');\nexport const sendOrderAsync = createAction('CHECKOUT_SEND_ORDER_ASYNC', async data => {\n  const response = await api.orders.createOrder(data);\n\n  if (response.status === 200) {\n    const {\n      message\n    } = await response.json();\n  } else {\n    const error = {\n      status: response.status\n    };\n  }\n});\nexport const checkoutActions = Object.freeze({\n  startFetching: () => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_START_FETCHING\n    };\n  },\n  stopFetching: () => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_STOP_FETCHING\n    };\n  },\n  setFetchingError: error => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_SET_FETCHING_ERROR,\n      payload: error\n    };\n  },\n  fillOrder: payload => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_FILL,\n      payload\n    };\n  },\n  setAccept: payload => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_SET_ACCEPT,\n      payload\n    };\n  },\n  // Async\n  sendOrderAsync: data => async dispatch => {\n    dispatch(checkoutActions.startFetching());\n    const response = await api.orders.createOrder(data);\n\n    if (response.status === 200) {\n      const {\n        message\n      } = await response.json();\n      dispatch(checkoutActions.setAccept(message));\n    } else {\n      const error = {\n        status: response.status\n      };\n      dispatch(checkoutActions.setFetchingError(error));\n    }\n\n    dispatch(checkoutActions.stopFetching());\n  }\n});","map":{"version":3,"sources":["F:/artem-pizza/client/src/pages/checkout-page/state/checkoutActions.js"],"names":["createAction","createAsyncThunk","api","checkoutActionTypes","startFetching","stopFetching","setFetchingError","fillOrder","setAccept","sendOrderAsync","data","response","orders","createOrder","status","message","json","error","checkoutActions","Object","freeze","type","CHECKOUT_START_FETCHING","CHECKOUT_STOP_FETCHING","CHECKOUT_SET_FETCHING_ERROR","payload","CHECKOUT_FILL","CHECKOUT_SET_ACCEPT","dispatch"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,gBAAvB,QAA+C,kBAA/C,C,CACA;;AACA,SAASC,GAAT,QAAoB,cAApB,C,CACA;;AACA,SAASC,mBAAT,QAAoC,uBAApC;AAEA,OAAO,MAAMC,aAAa,GAAGJ,YAAY,CAAC,yBAAD,CAAlC;AACP,OAAO,MAAMK,YAAY,GAAGL,YAAY,CAAC,wBAAD,CAAjC;AACP,OAAO,MAAMM,gBAAgB,GAAGN,YAAY,CAAC,6BAAD,CAArC;AACP,OAAO,MAAMO,SAAS,GAAGP,YAAY,CAAC,eAAD,CAA9B;AACP,OAAO,MAAMQ,SAAS,GAAGR,YAAY,CAAC,qBAAD,CAA9B;AACP,OAAO,MAAMS,cAAc,GAAGT,YAAY,CACxC,2BADwC,EAExC,MAAMU,IAAN,IAAe;AAGb,QAAMC,QAAQ,GAAG,MAAMT,GAAG,CAACU,MAAJ,CAAWC,WAAX,CAAuBH,IAAvB,CAAvB;;AACA,MAAIC,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,UAAM;AAAEC,MAAAA;AAAF,QAAc,MAAMJ,QAAQ,CAACK,IAAT,EAA1B;AAGD,GAJD,MAIO;AACL,UAAMC,KAAK,GAAG;AACZH,MAAAA,MAAM,EAAEH,QAAQ,CAACG;AADL,KAAd;AAID;AAEF,CAjBuC,CAAnC;AAsBP,OAAO,MAAMI,eAAe,GAAGC,MAAM,CAACC,MAAP,CAAc;AAC3ChB,EAAAA,aAAa,EAAE,MAAM;AACnB,WAAO;AAAEiB,MAAAA,IAAI,EAAElB,mBAAmB,CAACmB;AAA5B,KAAP;AACD,GAH0C;AAI3CjB,EAAAA,YAAY,EAAE,MAAM;AAClB,WAAO;AACLgB,MAAAA,IAAI,EAAElB,mBAAmB,CAACoB;AADrB,KAAP;AAGD,GAR0C;AAS3CjB,EAAAA,gBAAgB,EAAEW,KAAK,IAAI;AACzB,WAAO;AACLI,MAAAA,IAAI,EAAElB,mBAAmB,CAACqB,2BADrB;AAELC,MAAAA,OAAO,EAAER;AAFJ,KAAP;AAID,GAd0C;AAgB3CV,EAAAA,SAAS,EAAEkB,OAAO,IAAI;AACpB,WAAO;AACLJ,MAAAA,IAAI,EAAElB,mBAAmB,CAACuB,aADrB;AAELD,MAAAA;AAFK,KAAP;AAID,GArB0C;AAsB3CjB,EAAAA,SAAS,EAAEiB,OAAO,IAAI;AACpB,WAAO;AACLJ,MAAAA,IAAI,EAAElB,mBAAmB,CAACwB,mBADrB;AAELF,MAAAA;AAFK,KAAP;AAID,GA3B0C;AA6B3C;AACAhB,EAAAA,cAAc,EAAEC,IAAI,IAAI,MAAMkB,QAAN,IAAkB;AACxCA,IAAAA,QAAQ,CAACV,eAAe,CAACd,aAAhB,EAAD,CAAR;AAEA,UAAMO,QAAQ,GAAG,MAAMT,GAAG,CAACU,MAAJ,CAAWC,WAAX,CAAuBH,IAAvB,CAAvB;;AACA,QAAIC,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,YAAM;AAAEC,QAAAA;AAAF,UAAc,MAAMJ,QAAQ,CAACK,IAAT,EAA1B;AAEAY,MAAAA,QAAQ,CAACV,eAAe,CAACV,SAAhB,CAA0BO,OAA1B,CAAD,CAAR;AACD,KAJD,MAIO;AACL,YAAME,KAAK,GAAG;AACZH,QAAAA,MAAM,EAAEH,QAAQ,CAACG;AADL,OAAd;AAGAc,MAAAA,QAAQ,CAACV,eAAe,CAACZ,gBAAhB,CAAiCW,KAAjC,CAAD,CAAR;AACD;;AACDW,IAAAA,QAAQ,CAACV,eAAe,CAACb,YAAhB,EAAD,CAAR;AACD;AA7C0C,CAAd,CAAxB","sourcesContent":["import { createAction, createAsyncThunk } from '@reduxjs/toolkit';\n// Api\nimport { api } from '../../../api';\n// ActionTypes\nimport { checkoutActionTypes } from './checkoutActionTypes';\n\nexport const startFetching = createAction('CHECKOUT_START_FETCHING');\nexport const stopFetching = createAction('CHECKOUT_STOP_FETCHING');\nexport const setFetchingError = createAction('CHECKOUT_SET_FETCHING_ERROR');\nexport const fillOrder = createAction('CHECKOUT_FILL');\nexport const setAccept = createAction('CHECKOUT_SET_ACCEPT');\nexport const sendOrderAsync = createAction(\n  'CHECKOUT_SEND_ORDER_ASYNC',\n  async data =>  {\n\n\n    const response = await api.orders.createOrder(data);\n    if (response.status === 200) {\n      const { message } = await response.json();\n\n\n    } else {\n      const error = {\n        status: response.status,\n      };\n\n    }\n    \n  }\n);\n\n\n\nexport const checkoutActions = Object.freeze({\n  startFetching: () => {\n    return { type: checkoutActionTypes.CHECKOUT_START_FETCHING };\n  },\n  stopFetching: () => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_STOP_FETCHING,\n    };\n  },\n  setFetchingError: error => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_SET_FETCHING_ERROR,\n      payload: error,\n    };\n  },\n\n  fillOrder: payload => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_FILL,\n      payload,\n    };\n  },\n  setAccept: payload => {\n    return {\n      type: checkoutActionTypes.CHECKOUT_SET_ACCEPT,\n      payload,\n    };\n  },\n\n  // Async\n  sendOrderAsync: data => async dispatch => {\n    dispatch(checkoutActions.startFetching());\n\n    const response = await api.orders.createOrder(data);\n    if (response.status === 200) {\n      const { message } = await response.json();\n\n      dispatch(checkoutActions.setAccept(message));\n    } else {\n      const error = {\n        status: response.status,\n      };\n      dispatch(checkoutActions.setFetchingError(error));\n    }\n    dispatch(checkoutActions.stopFetching());\n  },\n});\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { createAction, createAsyncThunk } from '@reduxjs/toolkit'; // Api\n\nimport { api } from '../../../api';\nexport const startFetching = createAction('checkout/startFetching');\nexport const stopFetching = createAction('checkout/stopFetching');\nexport const setFetchingError = createAction('checkout/setFetchingError');\nexport const fillOrder = createAction('checkout/fill');\nexport const setAccept = createAction('checkout/setAccept');\nexport const sendOrderAsync = createAsyncThunk('checkout/sendOrderAsync', async (data, thunkAPI) => {\n  thunkAPI.dispatch(startFetching());\n  const response = await api.orders.createOrder(data);\n\n  if (response.status === 200) {\n    const {\n      message\n    } = await response.json();\n    thunkAPI.dispatch(fillOrder(message));\n    return message;\n  } else {\n    const error = {\n      status: response.status\n    };\n    thunkAPI.dispatch(setFetchingError(error));\n    return error;\n  }\n}); // export const checkoutActions = Object.freeze({\n//   startFetching: () => {\n//     return { type: checkoutActionTypes.checkout / START_FETCHING };\n//   },\n//   stopFetching: () => {\n//     return {\n//       type: checkoutActionTypes.checkout / STOP_FETCHING,\n//     };\n//   },\n//   setFetchingError: error => {\n//     return {\n//       type: checkoutActionTypes.checkout / SET_FETCHING_ERROR,\n//       payload: error,\n//     };\n//   },\n//   fillOrder: payload => {\n//     return {\n//       type: checkoutActionTypes.checkout / FILL,\n//       payload,\n//     };\n//   },\n//   setAccept: payload => {\n//     return {\n//       type: checkoutActionTypes.checkout / SET_ACCEPT,\n//       payload,\n//     };\n//   },\n//   // Async\n//   sendOrderAsync: data => async dispatch => {\n//     dispatch(checkoutActions.startFetching());\n//     const response = await api.orders.createOrder(data);\n//     if (response.status === 200) {\n//       const { message } = await response.json();\n//       dispatch(checkoutActions.setAccept(message));\n//     } else {\n//       const error = {\n//         status: response.status,\n//       };\n//       dispatch(checkoutActions.setFetchingError(error));\n//     }\n//     dispatch(checkoutActions.stopFetching());\n//   },\n// });","map":{"version":3,"sources":["F:/artem-pizza/client/src/pages/checkout-page/state/checkoutActions.js"],"names":["createAction","createAsyncThunk","api","startFetching","stopFetching","setFetchingError","fillOrder","setAccept","sendOrderAsync","data","thunkAPI","dispatch","response","orders","createOrder","status","message","json","error"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,gBAAvB,QAA+C,kBAA/C,C,CACA;;AACA,SAASC,GAAT,QAAoB,cAApB;AAEA,OAAO,MAAMC,aAAa,GAAGH,YAAY,CAAC,wBAAD,CAAlC;AACP,OAAO,MAAMI,YAAY,GAAGJ,YAAY,CAAC,uBAAD,CAAjC;AACP,OAAO,MAAMK,gBAAgB,GAAGL,YAAY,CAAC,2BAAD,CAArC;AACP,OAAO,MAAMM,SAAS,GAAGN,YAAY,CAAC,eAAD,CAA9B;AACP,OAAO,MAAMO,SAAS,GAAGP,YAAY,CAAC,oBAAD,CAA9B;AACP,OAAO,MAAMQ,cAAc,GAAGP,gBAAgB,CAC5C,yBAD4C,EAE5C,OAAOQ,IAAP,EAAaC,QAAb,KAA0B;AACxBA,EAAAA,QAAQ,CAACC,QAAT,CAAkBR,aAAa,EAA/B;AACA,QAAMS,QAAQ,GAAG,MAAMV,GAAG,CAACW,MAAJ,CAAWC,WAAX,CAAuBL,IAAvB,CAAvB;;AACA,MAAIG,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,UAAM;AAAEC,MAAAA;AAAF,QAAc,MAAMJ,QAAQ,CAACK,IAAT,EAA1B;AACAP,IAAAA,QAAQ,CAACC,QAAT,CAAkBL,SAAS,CAACU,OAAD,CAA3B;AACA,WAAOA,OAAP;AACD,GAJD,MAIO;AACL,UAAME,KAAK,GAAG;AACZH,MAAAA,MAAM,EAAEH,QAAQ,CAACG;AADL,KAAd;AAGAL,IAAAA,QAAQ,CAACC,QAAT,CAAkBN,gBAAgB,CAACa,KAAD,CAAlC;AAEA,WAAOA,KAAP;AACD;AACF,CAjB2C,CAAvC,C,CAoBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { createAction, createAsyncThunk } from '@reduxjs/toolkit';\n// Api\nimport { api } from '../../../api';\n\nexport const startFetching = createAction('checkout/startFetching');\nexport const stopFetching = createAction('checkout/stopFetching');\nexport const setFetchingError = createAction('checkout/setFetchingError');\nexport const fillOrder = createAction('checkout/fill');\nexport const setAccept = createAction('checkout/setAccept');\nexport const sendOrderAsync = createAsyncThunk(\n  'checkout/sendOrderAsync',\n  async (data, thunkAPI) => {\n    thunkAPI.dispatch(startFetching());\n    const response = await api.orders.createOrder(data);\n    if (response.status === 200) {\n      const { message } = await response.json();\n      thunkAPI.dispatch(fillOrder(message));\n      return message;\n    } else {\n      const error = {\n        status: response.status,\n      };\n      thunkAPI.dispatch(setFetchingError(error));\n\n      return error;\n    }\n  }\n);\n\n// export const checkoutActions = Object.freeze({\n//   startFetching: () => {\n//     return { type: checkoutActionTypes.checkout / START_FETCHING };\n//   },\n//   stopFetching: () => {\n//     return {\n//       type: checkoutActionTypes.checkout / STOP_FETCHING,\n//     };\n//   },\n//   setFetchingError: error => {\n//     return {\n//       type: checkoutActionTypes.checkout / SET_FETCHING_ERROR,\n//       payload: error,\n//     };\n//   },\n\n//   fillOrder: payload => {\n//     return {\n//       type: checkoutActionTypes.checkout / FILL,\n//       payload,\n//     };\n//   },\n//   setAccept: payload => {\n//     return {\n//       type: checkoutActionTypes.checkout / SET_ACCEPT,\n//       payload,\n//     };\n//   },\n\n//   // Async\n//   sendOrderAsync: data => async dispatch => {\n//     dispatch(checkoutActions.startFetching());\n\n//     const response = await api.orders.createOrder(data);\n//     if (response.status === 200) {\n//       const { message } = await response.json();\n\n//       dispatch(checkoutActions.setAccept(message));\n//     } else {\n//       const error = {\n//         status: response.status,\n//       };\n//       dispatch(checkoutActions.setFetchingError(error));\n//     }\n//     dispatch(checkoutActions.stopFetching());\n//   },\n// });\n"]},"metadata":{},"sourceType":"module"}